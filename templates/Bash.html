{% extends "layout.html" %}

{% block main %}
<section id="some-commands">
<h2>Some useful commands</h2>
<ul>
  <li><code>date</code> - shows the current date and time.</li>
  <li><code>cal</code> - displays a calendar of the current month.</li>
  <li><code>df</code> - shows the free disk space.</li>
  <li><code>free</code> - shows the free memory space.</li>
  <li> <code>file filename</code> - shows the filename's file type.</li>
  <li><code>locate path/name</code> - fid a file containing 'name' under 'path'</li>
  <li><code>less filename</code> - is a program for viewing long text documents. Press <code>h</code> for help
    navigating the file.</li>
  <li><code>type command</code> - shows what the <code>command</code> is.</li>
  <li><code>which command</code> - shows the location of the program (only works on executable programmes, not shell
    built ins or aliases).</li>
  <li><code>man n command</code> displays the manual page for that command, where <code>n</code> is the section number
    (see page 46 of TLCL for a section breakout).</li>
  <li><code>apropos search-term</code> - it returns all the man pages matching the search term.</li>
  <li><code>command --help</code> - diplays a help page on how to use the command. It's a lot more readable than de
    <code>man</code>.</li>
  <li><code>info command</code> - shows general information abaut the command.</li>
  <li> <code>uniq [file]</code> - removes duplicate adjacent lines from file or standard input.</li>
  <li> <code>wc [file]</code> - prints the line, word and byte count from file or stdin.</li>
  <li><code>grep regExp [file]</code>- prints the lines of the file (or stdin) that contain the regExp.</li>
  <li><code>tail</code> - besides printing the last 10 lines of a file, if used with the option <code>-f</code>, it
    keeps track of the file and prints new lines to the console as soon as they're written on the file until stopped
    with <code>ctrl-c</code>.</li>

  <li><code>tee file | command</code> - works as a Y-split in a pipeline, taking input and sending it to both stdout and
    a file (or several files).</li>
  <li><code>printenv</code> - displays all global variables.</li>
  <li><code>script [file]</code> - allows you to record an entire terminal session and store it in <code>file</code>.
  </li>
  <li><code>lsblk</code> - list all available block dheevices (I think it refers to USB things).</li>
  <li><code>gunzip</code> - Uncompress (decompress / unzip) files.</li>
  <li><code>gzip</code> - Compress files.</li>
  <li><code>unzip file.zip</code> - uncompress .zip file.</li>
  <li> <code>zip filename.zip file1 file2 ... fileN</code> - compress files. Filename is the name of the result compressed
    file.</li>
  <li><code>id</code> - display user ID.</li>
  <li><code>sed 's/old/new/g' file.txt</code> - Substitute all instances of <i>old</i> for <i>new</i>.</li>
  <li><code>bash -c command</code> - Run <code>command</code></li>
  <li><code>bash [option] script-file</code> - Run <code>script-file</code></li>
  <li><code>xargs [option]... COMMAND [INITIAL-ARGS]...</code> - Run COMMAND with arguments [INITIAL-ARGS] and more
    arguments read from input.</li>
  <li><code>lsb_release -a</code> - See OS info.</li>
  <li><code>ffmpeg -i in/infile.png -c:v libwebp out/outfile.webp</code> - Convert images to webp format using ffmpeg.</li>
  <li><code>cwebp -q 90 -lossless in_file -o out_file</code></li> - Convert images to webp format using cwebp.
  <li><code>vwebp image.webp</code> - Visualize .webp images</li>
<li><code>qrencode -o filename.png string</code> - Encode &lt;string&gt; into a QR code and save as &lt;filename&gt;</li>
<li><code>WIFI:T:WPA;S:&lt;your Wi-Fi network name&gt;P:&lt;your Wi-Fi network password&gt;</code></li> - Use this format to encode your wifi credentials into a QR code
<li><code>ffmpeg -fflags +genpts -i input.webm -r 24 output.mp4</code> - Convert webm video to MP4</li>
<li><code>${string%.*}</code> - remove everything after the '.' from <code>string</code></li>
<li><code>sudo dpkg -i filename.deb</code> - Install software from <code>.deb</code> file</li>
<li><code>openssl rand -base64 9</code> - Generate a random string of size 9 (ensure size is dibisible by 3 to avoid padding)</li>

</ul>

<h3>Wildcards</h3>
<div class="code"><img src="/static/Images/wildcards.jpg" alt="wildcards" height="180px"></div><br>
<div class="code"><img src="/static/Images/char_class.jpg" alt="Character Classes" height="150px"> </div>

</section>



<section id="virtual-terminals">
<h2>Virtual Terminals</h2>

<p>The virtual terminals are running behind de desktop even if there is no terminal session open. Acces them by pressing <code>ctl-alt-F1</code> (throguh F6). Once in the virtual terminal, navigate them with <code>alt-F1</code> to <code>alt-F6</code>.
    Return to the graphical desktop with <code>alt-F7</code>.</p>

</section>

<section id="links">
<h2>Soft links</h2>
<p>Soft links (aka symlinks or symbolic links) allow a file to be pointed at via a different name. When a symbolic link is deleted, the file keeps on existing, and if the file is deleted, the symbolic link will keep on existing but will point
    to nothing. These are called <i>broken links</i> and are ususally displayed in red by the <code>ls </code>command.<br> To create a symbolic link use <code>ln -s item link</code> where the option <code>-s</code> is for soft link, <code>item</code>                is the <strong>absolute filename</strong> to point at and <code>link</code> is the name of the link to create. </p>
<h3>Hard links</h3>
<p>All files have at least one hard link and that is its name, we can create another hard link using the same command as above without the <code>-s</code> option but hard links have two disadvantages: you can't reference a file on a different
    disk and you can't reference directories. This is why we usually use soft links</p>
</section>

<section id="redirection">
<h2>Redirection</h2>
<p>See redirection <a href="http://linuxcommand.org/lc3_lts0070.php">here</a>.</p>

<p>Redirection allows us to control where input comes from (keyboard by default) and where output goes to (screen as default). A command like <code>ls</code> sends it's output to standard output and it's errors to standard error. Any well written
    unix programms should do this to avoid redirecting errors and display them on the console instead.<br>See redirection of standard error on page 82.</p>

<h3>Discard output</h3>
<p>Redirect output to /dev/null; it is a program that accepts input and does nothing with it. Usually refered to as the <i>bit bucket</i>. To discard error messages use: <code>2&gt /dev/null</code>.</p>
</section>

<section id="arithmetics">
<h2>Arithmetics</h2>
<p>Artihmetic expressions in the command line look like this: <code>$((expression))</code>. If we want to nest operations, we can do it like this: <code>$(( ( expression1 ) + expression2 ))</code>.</p>

<h2>Expansions</h2>
<p>Expansion is what happens when what you type on the console is interpreted a number of whays by the Shell. Wildcards are one of them, you type in * and it gets expanded into every file in the directory in ascendent alphabetical or numerical
    order. <br>There's also the <i>parameter expansion</i> which is the one we use to display variable contents: <code>$variable</code>.<br>Another very useful expansion is the <em>history expansion</em>; if we want to use a command from the
    history, use <code>!xxx</code> where xxx is the line number.</p>
<h3>Brace expressions</h3>
<p>Brace expressions may contain a list of comma separated strings or a sequence of numbers or single characters: <code>{"one", "two", "three"}, {1..3}, {a..c}</code>. They get expanded and their values printed separately into stdout. See page
    96.
</p>

<p>When typing strings on the console, use double quotes to get rid of the special character's meaning and word splitting. Only $ \ and ` keep on working between double quotes, which means that parameter expansion, arithmetic operations and command
    substitution (when we use parameter expansion to use the output of a command as the input of another) will still take place. Use single quotes to supress all expansions. </p>
</section>

<section id="permissions">
<h2>Permissions</h2>
<p>
  In the Unix security model, a user may own files and directories. When a user owns a file
or directory, the user has control over its access. Users can, in turn, belong to a group
consisting of one or more users who are given access to files and directories by their
owners. In addition to granting access to a group, an owner may also grant some set of
access rights to everybody, which in Unix terms is referred to as the <i>world</i>. To find information about your identity, use the <code>id</code> command.
</p>

<p>
  The <code>chmod</code> command is used for changing the mode (permissions) of a file or directory. Only the file's owner and the superuser are allowed to make changes in permissions. Using 3 octal digits allows us to set peprmissions for the
    owner, group owner and world respectively: 
  </p>
<img src="/static/Images/octal.jpg" height="220px">

<p>
  Alternatively, symbolic notation may be used. The first part of symbolic notation specifies who the changes apply to:
  u (user/owner), g (group), o (others/world), a (all) and the second part says what permissions are being modified: r,
  w,
  x or any combination. Use + to add permisions, - to remove and = to apply only the specified permissions and remove
  all others. Example: <code>chmod u+rwx</code> gives the file owner permission to read, write and execute. If the first
  part is omitted, all is assumed.
</p>

<h3><code>umask</code> - Set default permissions</h3>
<p>
  This command controls the default permissions given to a file when it is created. It uses octal notation to represent a <i>mask</i> of bits to be removed from the file attributes. If we expand the octal value of mask into binary, we can see how it works.
</p>
<script src="https://gist.github.com/alvarezrrj/78c0fcbda507d73c308e9b06420fe69c.js"></script>
<p>
  We can see that everywhere a 1 appears on the binary value of the mask, a file attribute is removed.
</p>

<h3>Changing identity</h3>
<p>It is possible to start a shell session as another user by using the command <code>su [-l] [user]</code>. Use <code>sudo su -</code> to start a session as the superuser.</p>

<h3>Change owner</h3>
<p>Use <code>chmod [owner][:[group]] file...</code></p>
<img src="/static/Images/chown.jpg" alt="chown" height="200px">

<h3>Create a shared directory</h3>
<p>
  First, creatae a group and add all users who need access to the directory to it. Then use <code>chown :&lt;group_name&gt; /path/to/shared-dir</code> to make the directory owned by the group and <code>chmod 775 /path/to/shared-dir</code> to give the group members read, write and execute (execute permission is needed in directories in order to access them) permissions on the directory.
</p>
<p>
  We now have a directory owned by the group that allows all gorup members to create files but those files will be given the users default permissions (probably something like -rw-r--r--) so we need to change the users <code>umask</code> to 0002. But there's still a problem, each file created will be given the default group it's creator belongs to instead of &lt;group_name&gt;. This can be fixed by setting the <i>setgid</i> bit on the directory, which is shows ap as an <code>s</code> on the directory listing and means all files created under the directory will belong to the same group the directory does, not to the file creator's group. To do this use <code>sudo chmod g+s /path/to/shared-dir</code>
</p>
</section>

<section id="processes">
<h2>Processes</h2>
<p>Use <code>ps x</code> for a list of processes currently running. See page 112 for the meaning of the STAT column.<br> Use <code>top</code> for a self updating list of the top processes currently running. Press 'h' for help.<br> To start a
    process in the background, follow the commant with an smpersand: <code> [command] &</code>. When processes are running in the background, we can request a list of them with the command <code>jobs</code> and use the info given to bring
    a process back to the foreground with <code>fg %#</code> where # is the job number. Pause a process using <code>Ctrl-Z</code> and send it to the background using <code>bg %#</code>. </p>

<h3>Signals</h3>
<p>Use <code>kill [signal] PID</code> to send a signal to a program. If no signal is specified, a TERM (terminate) signal is sent and the program is ended. See page 120 for a list of signals.</p>
</section>

<section id="compiling">
<h2>Compiling</h2>
<p>Start by creating a directory called <code>src</code> containing the source code. Download the source code (tarball) with a <code>wget</code> or a <code>ftp</code>.<br>
Then run <code>./configure</code> and after that run <code>make</code>.<br>
Once the program has been built, run <code>sudo make install</code>. The program will typically be installed in <code>/usr/local/bin</code>. </p>
</section>

<section id="environment">
<h2>Configuring the environment</h2>
<p><ul>Some useful commands
    <li><code>set</code> - print environment and shell variables.</li>
    <li><code>printenv</code> - print environment variables</li>
    <li><code>alias</code> - use it without options or arguments to list all aliases.</li>
    <li><code>export var_name=value</code> - set environment variable <code>var_name</code> to <code>value</code></li>
</ul>
</p>
</section>

<section id="shortcuts">
<h2>Keyboard shortcuts</h2>
<figure><figcaption style="font-size:1.5rem;">Cursor movement</figcaption>
<img src="/static/Images/cursor.jpg" alt="Cursor movement shortcuts" height="250px">
</figure>

<figure><figcaption style="font-size:1.5rem;">Text editing</figcaption>
<img src="/static/Images/text-shortcuts.jpg" alt="Text editing shortcuts" height="220px">
</figure>

<figure><figcaption style="font-size:1.5rem;">Killing and yanking</figcaption>
    <img src="/static/Images/yanking.jpg" alt="Killing and yanking shortcuts" height="220px">>
</figure>
</section>

<section id="packages">
<h2>Package Management</h2>
<p>When a package is downloaded from a source other than a repository, use <code>dpkg -i package_file</code> to install it.</p>

<p><b>Remove</b> a package with <code>apt remove package-name</code>.</p>

<p>Apparently, <code>dpkg</code> can be used to create packages. We'll have to find out how. Take a look at Debian packaging <a href="https://www.debian.org/doc/devel-manuals#packaging-tutorial">here</a>.</p>
</section>

<section id="storage">
<h2>Storage Media</h2>
<h3>Mounting</h3>
<p>The first step in managing a storage device is attaching it to the file system tree (mounting). The <code>mount</code> command is used for mounting: <code>mount -t device-type device-name location</code> The -t flag is for specifying the device type. To find out what the device name is use <code>tail -f /var/log/messages</code> and watch what happens when you insert the device. Another option would be to compare the contents of the /dev directory (where all the devices live) before and after inserting the device. Use <code>umount device-name</code> to unmount a device.<br>
Using <code>mount</code> without arguments prints a list of currently mounted file systems. </p>
<p>The file /etc/fstab (File System Table) lists the devices that are to be mounted on boot.</p>

<h3>Manipulating partiitons with <code>fdisk</code></h3>
<p>To format and create new partitions on a storage device first unmount it and then use <code>fdisk device-name</code> and follow the instructions.</p>
<p>To create a new file system use <code>mkfs -t file-system-type device-partition-to-format</code>.</p>
</p>

<h3>Checking and repairing file systems</h3>
<p>The <code>fsck device-partition</code> command checks the integrity of the device's partition given (fuck knows what it does in the background) and recovered files from corrupted disks are stored in the lost+found directory. </p>
</section>

<section id="networking">
<h2>Networking</h2>
<h3>Examine the network</h3>
<p>The <code>ping</code> command sends a ICMP ECHO_REQUEST network packet to a specified host. Most devices receiving this packet will reply to it although devices can be configured to ignore it. Once started, <code>ping</code> will continue sending packets at a specified interval until interrupted.</p>

<p>The <code>traceroute</code> command lists all the hops network traffic takes to get from the local device to a specified host. For each hop the program returns the router's hostname, IP address and performance (in the shape of time time taken for three round trips from the local device to the router).</p>

<p>The <code>ip</code> command replaces old <code>ifconfig</code> and is used to examine a system networking things.
</p>

<p>The <code>netstat</code> command is another network checking program. Use <code>netstat -ie</code> to examine the network interfaces in your system.
</p>

<h3>File Transfer</h3>

<p>The <code>ftp</code> (<i>File Transfer Protocol</i>) program is used to interact with ftp servers. Machines that contain files which can be downloaded and uploaded over a network. Bare in mind <code>ftp</code> is a non secure connection.<br>
Use <code><b>sftp</b></code> for an encrypted connection. <code>sftp</code> uses and ssh tunnel for transfering the data, which means that an ftp server does not need to be running in the remote machine for you to be able to connect to it using sftp. Only the ssh server needs to be running.<br>
The SFTP protocol is supported by many of the GUI file managers. This allows you to insert the username and host as a uri on the search bar of your file manager (sftp://username@host) and acces the remote machine's file system.
</p>

<p>A better version of the above is <code>lftp</code> which includes support for HTTP and other cool features like tab completion.</p>

<p>The <code>scp</code> (Secure copy) program allows you to send and retrieve files to and from a remote machin in a secure way. To copy the file <code>foo</code> from <code>remote-sys</code> into the current working directory use <code>scp user@remote-sys:foo</code>
</p>

<p>Run a remote GUI through <code>ssh</code> by using the -X flag, which allows you to run graphical programs on the remote machine. Then, once logged in to the remote machine, run the <code>xload</code> command.</p>

</section>

<section id="backups">
  <h2>Backing up a Linux System</h2>
  <p>
    <code>cd</code> into the root directory and run the following line (as superuser) to compress everything
  </p>

  <p>
    <code>tar cvpzf backup.tar.gz --exclude=/backup.tgz --exclude=/proc --exclude=/lost+found  --exclude=/mnt --exclude=/media --exclude=/sys --exclude=/run --exclude=/dev /</code>
  </p>

  <p>The options in the above command mean:
    <ul>
      <li>Create archive</li>
      <li>Verbose mode</li>
      <li>Preserve permissions</li>
      <li>Compress using gzip</li>
      <li>Filename</li>
    </ul>
  </p>

  <h3>Restoring</h3>
  <p>You can do this on a running system if you want. Run the following line</p>
  <p>
    <code>tar xvpfz backup.tar.gz -C /</code>
  </p>
  <p>
    Re-create the directories you excluded and reboot
  </p>
  <p>
    <code>
      sudo mkdir proc lost+found mnt media sys run dev
    </code>
  </p>


</section>
{% endblock %}